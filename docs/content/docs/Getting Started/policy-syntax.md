---
title: "Policy Syntax"
date: 2021-05-30T22:10:26+01:00
weight: 2
---

Policies are at the core of Aspect, driving all of the evaluation logic whether it's coming from the [REPL UI](/docs/cli-commands/aspect-inspect/), from a file on disk, or one of the [BuiltIn Policies](/docs/builtin). The syntax of the document is largely inspired by Rego, from the Open Policy Agent project. Each policy must have a minimum of two parts: a `resource` statement and a `validate` statement block.

{{< code lang="tf" >}}
resource "AwsSecurityGroup"

validate {
    input.Name == "default"
}
{{< /code >}}

The resource can be any of one of the supported resources, which you can view from running [`aspect resources`](/docs/cli-commands/aspect-resources/). Once set, you have access to a special variable called `input` which allows you access to the currently evaluating resource in any one of the statement blocks. From here, you will get full type checking during policy evaluation and validation. To view the available properties for a specific resource, follow the documentation link generated by [`aspect resources`](/docs/cli-commands/aspect-resources/).

## Statement Blocks

There are three available statement blocks that can be defined in any order: `include`, `exclude`, `validate`. Each one of the statement blocks has the exact same structure:

{{< code lang="tf" >}}
<statement block name> {
    <statement expression 1>
    <statement expression 2>
    <statement expression 3>
}
{{< /code >}}

Each statement within a statement block is newline delimited and then logically anded together with the previous statements. If any statement does not successfuly validate against the specified input, then the statement block fails. The effect of a statement block failure depends on the nature of the block. See the [Evaluation Logic](#evaluation-logic) for more details.

Each statement expression is always one of the following syntaxes:

{{< code lang="tf" >}}
<statement block name> {
    input.<accessor> <operator> <constant value>
    <function name>(input.<accessor>, <constant value> [, <constant value N>])
}
{{< /code >}}

Note how the `input` is always on the left side of the statement expression. The only time this is not strictly required is when there is a [function call](#functions). Let's take a look at an example `validate` block: 

{{< code lang="tf" >}}
validate {
    input.Name == "Test"
    input.Region == "eu-west-1"
}
{{< /code >}}

In the above statement block, we have defined two statements:

1. `input.Name == "Test"` - The name of the resource must be equal to `Test`
1. `input.Region == "eu-west-1"` - The resource must be in the `eu-west-1` region

If either of the above conditions fails, then the corresponding statement block (`validate` in this example) fails. The following statement blocks are available to be defined in any other:

{{< table style="table-striped" >}}
|Name|Description|Required?|
|---|---|---|
|validate|Validates a cloud resource against the specified criteria. This block must contain at least one statement.|Yes|
|include|Include resources that match the specified criteria|No|
|Exclude|Exclude resources that match the specified criteria|No|
{{< /table >}}

Note: _Statement blocks cannot be nested inside of one another._

If a resource has nested properties, use dot notation to access the properties, for example:

{{< code lang="tf" >}}
validate {
    input.Account.Id == "Test"
}
{{< /code >}}

## Operators

Depending on the type that you are evaluating, the following operators are available to use:

{{< table style="table-striped" >}}
|Operator|Available on Types|Description|
|---|---|---|
|==|String, Boolean, Number|The left operand must be **equal** to the right operand|
|!=|String, Boolean, Number|The left operand must **not be equal** to the right operand|
|>|Number|The left operand must be **greater than** the right operand|
|>=|Number|The left operand must be **greater than or equal to** the right operand|
|<|Number|The left operand must be **less than** the right operand|
|<=|Number|The left operand must be **less than or equal to** the right operand|
{{< /table >}}


## Type System

Aspects type system is designed to be as simple as possible to reason about. Therefore, we only have the following types:

{{< table style="table-striped" >}}
|Name|Description|Examples|
|---|---|---|
|String|Represents a peice of text|"Hello", "World"|
|Number|Represents either an integer or decimal value, which can either be positive or negative. Subject to type coercion|-1, 1, 3.142|
|Boolean|Represents a true or false value|true, false|
|Collection\<T>|Represents a collection of the specified type T, where T is either part of a resource or a KeyValuePair|[1,2,3]|
|KeyValuePair|Represents a key and value which both are of type String.|Key:Hello, Value:World|
{{< /table >}}

### Type coercion

Aspect performs some very basic type coercion on your behalf. For example, if you want to check if `1` is equal to `1.2`, Aspect will correct the data types if it can so that the equality check has a chance to succeed. If the input and the constant expressions can not be coerced, you will recieve a compiler error which will need to be fixed.

### Collections

A lot of the resources that area available in Aspect have one or more collections contained inside, often with resources nested underneath them. A good example of this is the `[AwsSecurityGroup](/docs/aws/resources/awssecuritygroup/)` which has the the `IngressRules` property, with a nested collection for `IPV4Ranges`. You can access collections using the following syntax declarations:

{{< code lang="tf" >}}
<statement block name> {
    input.<collection name>[<access type>] <operator> <constant value>
}
{{< /code >}}

The `<access type>` can either be set to ensure that all elements in a collection match the specified syntax, using the `input.<collection name>[_]` syntax: 

{{< code lang="tf" >}}
<statement block name> {
    input.<collection name>[_] <operator> <constant value>
}

# eg:

validate {
    input.CollectionOfNumbers[_] > 0
}
{{< /code >}}

; or they can be set to match any element in the collection using the `input.<collection name>[*]` syntax:

{{< code lang="tf" >}}
<statement block name> {
    input.<collection name>[*] <operator> <constant value>
}

# eg:

validate {
    input.CollectionOfNumbers[*] > 0
}
{{< /code >}}

Take a look at the following examples of how to use collections:

{{< table style="table-striped" >}}
|input|Description|
|---|---|
|`input.Collection[_] == 1`|All elements in `Collection` must be equal to `1`|
|`input.Collection[*] == 1`|Any element in `Collection` must be equal to `1`|
|`input.Collection[_].SubCollection[*] == 1`|All elements in `Collection` must have a `SubCollection` element equal to `1`|
|`input.Collection[*].SubCollection[_] == 1`|Any element in `Collection` must have all elements in `SubCollection` equal to `1`|
{{< /table >}}


## Functions

When building your policies, you may which to perform certain operations like seeing whether or not a string contains a specific value. Aspect provides you with a set of built in functions to help you. Please see the [BuiltIn Functions](/docs/getting-started/builtin-functions/) documentation to see how to use functions properly.

{{< alert style="danger" >}}**Note:** _You cannot use functions with anything other than `collection<KeyValuePair>` which has limited function support._{{< /alert >}}

## Evaluation Logic

Now that we know the basics of constructing our policies, it's important to understand how the policies are evaluated against cloud resources. The flow is always:

1. Discover all resources available
1. Remove any resources that do not validate against the `include` statement block
1. Remove any resources that do not validate against the `exclude` statement block
1. Validate the remaining resources against the `validate` statement block

Or more visually:

![Full Policy Valiation](/img/policy-syntax/Full-Evaluation.png)

Let's take a look at this in more detail with a more real life scenario:

{{< lead >}} For each `AwsSecurityGroup` in the `Product-Group` `Contoso` where there is no tag `IsPublic` ensure that there are no global ingress rules {{< /lead >}}

We would write the policy as follows:

{{< code lang="tf" >}}
resource "AwsSecurityGroup"

include {
    contains(input.Tags, "Product-Group", "Contoso")
}

exclude {
    contains(input.Tags, "IsPublic", "true")
}

validate {
    input.EgressRules[*].IPV4Ranges[*].CIDR != "0.0.0.0/0"
}
{{< /code >}}

Now, let's imagine that we have the following resources that were discovered:

1. Security Group with an egress rule containing IPV4 CIDR Range 0.0.0.0/0
    - Tags:
        - Product-Group: Test
2. Security Group with an egress rule containing IPV4 CIDR Range 0.0.0.0/0
    - Tags:
        - Product-Group: Contoso
3. Security Group with an egress rule containing IPV4 CIDR Range 0.0.0.0/0
    - Tags:
        - Product-Group: Contoso
        - IsPublic: true
4. Security Group with an egress rule containing IPV4 CIDR Range 0.0.0.0/0
    - Tags:
        - Product-Group: Contoso
        - IsPublic: false

Here is how the policy would be evaluated for the above resources:

1. The `include` block would check to see whether each resource has the tag named `Product-Group` with the value `Contoso`. Resource #1 does not meet this condition, so it removed from further evaluations.
1. The `exclude` block would now be processed against resources 2, 3 & 4 as they all match the `Product-Group` tag. Resource #3 meets the criteria of having the tag `IsPublic` set to `true` so it is removed from further evaluations. Resource #4 does have the correct key, but an incorrect value so it remains for the final evaluation block.
1. The `validate` block is looking for any egress rule with an open CIDR range `0.0.0.0/0` which both the remaining resources (2 & 4) match. These resources are marked as failed.

In quite a few scenarios, it's possible to merge the `include` and `exclude` statement expressions for smaller policies, but the flexibility is there should you need something more complex. The rule of thumb is always: how easy is this policy to reason about? will someone new understand this policy if they are new to the system?